1. Pixel Art to Melody
用户可以在网格上绘制像素图，系统会自动将其转换为 8-bit 旋律。
像素点的位置决定音符的音高和时间：
纵轴（Y 轴）代表音高，越高的像素点对应越高的音符。
横轴（X 轴）代表时间（节拍），从左到右按顺序播放音符。


2. Pixel Art 颜色 = 不同音色
用户可以使用不同颜色的像素，每种颜色代表不同的音色（波形类型），从而丰富旋律的层次感。
音色映射：
红色 → 方波（Square Wave），适用于主旋律。
蓝色 → 三角波（Triangle Wave），适用于低音。
绿色 → 噪声（Noise），适用于打击乐器，如鼓点。
黄色 → 波形合成（Wave Table），适用于和弦或背景音。
用户交互：
在网格上选择颜色，然后点击像素点放置音符并设定音色。
右键点击像素点可以更换颜色（音色）。
拖拽绘制模式，用户可以快速填充或修改音符颜色。


3. 选择不同的芯片音源
用户可以选择不同的 8-bit 音源芯片，以模拟不同的复古游戏机风格。
可选芯片：
NES (2A03) 芯片，包含方波、三角波、噪声和 PCM 声道。
Game Boy (LR35902) 芯片，采用波形合成方式，音色更加柔和。
Commodore 64 (SID Chip) 芯片，带模拟滤波器，音色更丰富。
用户交互：
在 UI 菜单中选择芯片类型，系统自动调整音色限制和音轨风格。
预设示例旋律，让用户直观体验不同芯片的音色效果。


4. 上传音频文件 → 转换为 8-bit 音频
用户可以上传音频文件（支持 WAV 或 MP3），系统会自动转换为 8-bit 风格音频，并提供试听和下载。
用户交互：
选择本地音频文件上传。
处理完成后，用户可以试听转换前后的音频。
支持下载转换后的 8-bit 音频文件（WAV 格式）。
技术实现：
通过 Web Audio API 或 ffmpeg.js 进行比特率降采样（如 22050Hz）。
通过波形量化处理，使声音更接近 8-bit 游戏机风格。


5. 网格音符编辑（可调节网格长度 + 颜色更换）
用户可以调整网格的列数，以适应不同长度的旋律。
用户交互：
通过 UI 输入框或滑动条调整网格列数。
网格行数保持不变，但列数可自由伸缩（例如 16 列、32 列、48 列）。
旋律的播放时间会根据列数自动调整，以匹配新的节奏。
技术实现：
动态创建网格数组，并根据用户设定的列数重新渲染 UI。
播放时，根据网格列数调整 BPM（节奏速度），确保旋律完整播放。


6. 预设 Pixel Art 作品
系统内置一些经典像素图，用户可以直接播放这些像素画对应的旋律，或者修改这些像素图，创造自己的旋律。
用户交互：
选择预设像素图，系统会自动填充网格。
用户可以修改像素，调整旋律，再次播放。
支持保存用户修改后的作品，以供日后加载使用。